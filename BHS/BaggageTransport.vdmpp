-- Represents transportation system. It is a directed graph 
-- where stations are represented as nodes and segments 
-- between stations are represented as edges.
class BaggageTransport is subclass of Global
types

public TransportLayout = seq of Station * seq1 of (seq1 of nat);


values

public SampleLayout1 : TransportLayout = mk_(
  [
    new CheckInStation(mk_token(1), "CheckIn1"),
    new CheckInStation(mk_token(2), "CheckIn2"),
    new CombineStation(mk_token(3), "Combiner1"),
    new TrackingStation(mk_token(4), "Tracker1"),
    new ManualEncodingStation(mk_token(5), "ManualEncoder1"),
    new ScreeningL1Station(mk_token(6), "Screening1"),
    new DestructionStation(mk_token(7), "Destroyer1"),
    new SortationStation(mk_token(8), "Sortation"),
    new DischargeStation(mk_token(9), "ToBeijing"),
    new DischargeStation(mk_token(10), "ToLondon"),
    new DischargeStation(mk_token(11), "ToNewYork"),
    new DischargeStation(mk_token(12), "ToCph")
  ],
  [
    [ 0,  0, 35,  0,  0,  0,  0,  0,  0,  0,  0,  0], --  1. CheckIn1
    [ 0,  0, 20,  0,  0,  0,  0,  0,  0,  0,  0,  0], --  2. CheckIn2
    [ 0,  0,  0, 30,  0,  0,  0,  0,  0,  0,  0,  0], --  3. Combiner1
    [ 0,  0,  0,  0, 40, 20,  0,  0,  0,  0,  0,  0], --  4. Tracker1
    [ 0,  0,  0,  0,  0, 20,  0,  0,  0,  0,  0,  0], --  5. ManualEncoder1
    [ 0,  0,  0,  0,  0,  0, 40, 20,  0,  0,  0,  0], --  6. Screening1
    [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0], --  7. Destroyer1
    [ 0,  0,  0,  0,  0,  0,  0,  0, 10, 10, 10, 10], --  8. Sortation
    [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0], --  9. To Beijing
    [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0], -- 10. To London
    [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0], -- 11. To NewYork
    [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0]  -- 12. To Copenhagen
  ]
)

instance variables

private stations : map seq of char to Station;
private segments : set of Segment;


operations

public BaggageTransport: () ==> BaggageTransport
BaggageTransport() ==
  (
    stations := { |-> };
    segments := {};
  );


public static LoadSampleLayout1 : () ==> BaggageTransport
LoadSampleLayout1() ==
  return Load(SampleLayout1);

public static Load : TransportLayout ==> BaggageTransport
Load(layout) == 
  (
    dcl bt : BaggageTransport := new BaggageTransport();
    def mk_(stationSeq, distanceMatrix) = layout in
    (
      for station in stationSeq do
      (
        bt.AddStation(station);
      );
      for all i in set inds distanceMatrix do
      (
        for all j in set inds distanceMatrix(i) do
        (
          if distanceMatrix(i)(j) <> 0 
          then (
            dcl s1 : Station := stationSeq(i);
            dcl s2 : Station := stationSeq(j);
            dcl distance : nat1 := distanceMatrix(i)(j);
            dcl segment : Segment := 
              new Segment(s1, s2, distance);
            bt.AddSegment(segment);
            skip;
          );
        );
      );
    );
    return bt;
  );


public GetStation : seq of char ==> Station
GetStation(pStationName) ==
  return stations(pStationName);

public AddStation : Station ==> ()
AddStation(pStation) ==
  (
    stations := stations munion { pStation.GetName() |-> pStation };
  );
-- TODO: Precondition, ensure that station id does not exit

public AddSegment : Segment ==> ()
AddSegment(pSegment) ==
  (
    segments := segments union { pSegment };
  );
-- TODO: Add precondition to ensure that 
-- 1) A segment with the same from and to station cannot exist
-- 2) Two segments with the same set of stations cannot exist

public Step : () ==> ()
Step() ==
  (
    for all station in set rng stations
    do station.Step();

    for all segment in set segments
    do segment.Step();
  );

public ToJSON : () ==> seq of char
ToJSON() ==
  (
    dcl data : seq of char := "";
    dcl tote : [Tote] := nil;
    data := data ^ "{ \"stations\": [";
    data := data ^ ConvertStationsToJSON(rng stations);
    data := data ^ "], \"segments\": [";
    data := data ^ ConvertSegmentsToJSON(segments);
    data := data ^ "]}";
    return data;
  );

private pure ConvertSegmentsToJSON : set of Segment ==> seq of char
ConvertSegmentsToJSON(pSegments) ==
  (
    dcl data : seq of char := "";
    if pSegments <> {}
    then (
      let segment in set pSegments in
      let
        nextJson = ConvertSegmentsToJSON(pSegments \ { segment }),
        source = segment.GetSourceStation(),
        target = segment.GetTargetStation(),
        distance = segment.GetDistance(),
        totePositions = segment.GetTotePositions()
      in (
        data := data ^ "{ \"source\": \"" ^ source.GetName() ^ "\",";
        data := data ^ " \"target\": \"" ^ target.GetName() ^ "\",";
        data := data ^ " \"distance\": " ^ VDMUtil`val2seq_of_char[nat](distance) ^ ",";
        data := data ^ " \"totes\": [";
        data := data ^ ConvertTotePositionsToJSON(totePositions);
        data := data ^ "]}";
        if nextJson <> ""
        then data := data ^ ", " ^ nextJson;
      );
    );
    return data;
  );

private pure ConvertStationsToJSON : set of Station ==> seq of char
ConvertStationsToJSON(pStations) ==
  (
    dcl data : seq of char := "";
    if pStations <> {}
    then (
      let station in set pStations in
      let
        nextJson = ConvertStationsToJSON(pStations \ { station }),
        tote = station.GetCurrentTote()
      in (
        data := data ^ "{ \"name\": \"" ^ station.GetName() ^ "\"";
        data := data ^ ", \"totes\": [";
        if tote <> nil
        then data := data ^ " { \"id\": " ^ VDMUtil`val2seq_of_char[nat](tote.GetId()) ^ " }";
        data := data ^ "]";
        data := data ^ "}";

        if nextJson <> ""
        then data := data ^ ", " ^ nextJson;
      );
    );
    return data;
  );

private pure ConvertTotePositionsToJSON : seq of Segment`TotePosition ==> seq of char
ConvertTotePositionsToJSON(pTotePositions) ==
  (
    dcl data : seq of char := "";
    if pTotePositions <> []
    then (
     let
        totePos = pTotePositions(1),
        nextJson = ConvertTotePositionsToJSON(tl pTotePositions),
        toteId = VDMUtil`val2seq_of_char[nat](totePos.Tote.GetId()),
        position = VDMUtil`val2seq_of_char[nat](totePos.Position)
      in (
        data := "{ \"id\": " ^ toteId ^ ", \"position\": " ^ position ^ "}";
        if nextJson <> ""
        then data := data ^ ", " ^ nextJson;
      );
    );
    return data;
  );

end BaggageTransport