-- Represents transportation system. It is a directed graph 
-- where stations are represented as nodes and segments 
-- between stations are represented as edges.
class BaggageTransport is subclass of Global
types

public TransportLayout = seq of Station * seq1 of (seq1 of nat);


values

public SampleLayout1 : TransportLayout = mk_(
  [
    new CheckInStation(mk_token(1), "CheckIn1"),
    new CheckInStation(mk_token(2), "CheckIn2"),
    new CombineStation(mk_token(3), "Combiner1"),
    new DischargeStation(mk_token(4), "Discharge1")
  ],
  [
    [ 0,  0, 30,  0],
    [ 0,  0, 20,  0],
    [ 0,  0,  0, 30],
    [ 0,  0,  0,  0]
  ]
)

instance variables

private stations : map seq of char to Station;
private segments : set of Segment;


operations

public BaggageTransport: () ==> BaggageTransport
BaggageTransport() ==
  (
    stations := { |-> };
    segments := {};
  );


public static LoadSampleLayout1 : () ==> BaggageTransport
LoadSampleLayout1() ==
  return Load(SampleLayout1);

public static Load : TransportLayout ==> BaggageTransport
Load(layout) == 
  (
    dcl bt : BaggageTransport := new BaggageTransport();
    def mk_(stationSeq, distanceMatrix) = layout in
    (
      for station in stationSeq do
      (
        bt.AddStation(station);
      );
      for all i in set inds distanceMatrix do
      (
        for all j in set inds distanceMatrix(i) do
        (
          if distanceMatrix(i)(j) <> 0 
          then (
            dcl s1 : Station := stationSeq(i);
            dcl s2 : Station := stationSeq(j);
            dcl distance : nat1 := distanceMatrix(i)(j);
            dcl segment : Segment := 
              new Segment(s1, s2, distance);
            bt.AddSegment(segment);
            skip;
          );
        );
      );
    );
    return bt;
  );


public GetStation : seq of char ==> Station
GetStation(pStationName) ==
  return stations(pStationName);

public AddStation : Station ==> ()
AddStation(pStation) ==
  (
    stations := stations munion { pStation.GetName() |-> pStation };
  );
-- TODO: Precondition, ensure that station id does not exit

public AddSegment : Segment ==> ()
AddSegment(pSegment) ==
  (
    segments := segments union { pSegment };
  );
-- TODO: Add precondition to ensure that 
-- 1) A segment with the same from and to station cannot exist
-- 2) Two segments with the same set of stations cannot exist

public Step : () ==> ()
Step() ==
  (
    for all station in set rng stations
    do station.Step();

    for all segment in set segments
    do segment.Step();
  );

public ToGraphViz : () ==> seq of char
ToGraphViz() ==
  (
    dcl data : seq of char := "";
    data := data ^ "digraph ER {\n";
    for all station in set rng stations
    do data := data ^ GenerateGraphVizNode(station);
    for all segment in set segments
    do data := data ^ GenerateGraphVizEdge(segment);
    data := data ^ "}\n";
    return data;
  );

private pure GenerateGraphVizEdge : Segment ==> seq of char
GenerateGraphVizEdge(segment) ==
  (
    dcl data : seq of char := "";
    dcl label : seq of char := "";
    label := label ^ VDMUtil`val2seq_of_char[nat1](segment.GetDistance()) ^ " ";
    for totePos in segment.GetTotePositions()
    do (
      label := label ^ "t" ^ VDMUtil`val2seq_of_char[nat](totePos.Tote.GetId());
      label := label ^ ":" ^ VDMUtil`val2seq_of_char[nat](totePos.Position);
      label := label ^ " ";
    );
    data := data ^ "  ";
    data := data ^ segment.GetSourceStation().GetName();
    data := data ^ " -> ";
    data := data ^ segment.GetTargetStation().GetName();
    data := data ^ " [ ";
    data := data ^ " label=\"" ^  label ^  "\"";
    data := data ^ " ]";
    data := data ^ ";\n";
    return data;
  );

private pure GenerateGraphVizNode : Station ==> seq of char
GenerateGraphVizNode(station) ==
  (
    dcl data : seq of char := "  ";
    data := data ^ station.GetName();
    data := data ^ " [label=\""  ^ station.GetName();
    if station.GetCurrentTote() <> nil then
    (
      data := data ^ "\\nt:" ^ VDMUtil`val2seq_of_char[nat](station.GetCurrentTote().GetId());
    );

    data := data ^ "\"];\n";
    return data;
  );

functions


traces
-- TODO Define Combinatorial Test Traces here
end BaggageTransport