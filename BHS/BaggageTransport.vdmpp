-- Represents transportation system. It is a directed graph 
-- where stations are represented as nodes and segments 
-- between stations are represented as edges.
class BaggageTransport is subclass of Global
types

public TransportLayout = seq of Station * seq1 of (seq1 of nat);


values

public SampleLayout1 : TransportLayout = mk_(
  [
    new CheckInStation(mk_token(1), "CheckIn1"),
    new CheckInStation(mk_token(2), "CheckIn2"),
    new CombineStation(mk_token(3), "Combiner1"),
    new DischargeStation(mk_token(4), "Discharge1")
  ],
  [
    [ 0,  0, 30,  0],
    [ 0,  0, 20,  0],
    [ 0,  0,  0, 30],
    [ 0,  0,  0,  0]
  ]
)

instance variables

private stations : map seq of char to Station;
private segments : set of Segment;


operations

public BaggageTransport: () ==> BaggageTransport
BaggageTransport() ==
  (
    stations := { |-> };
    segments := {};
  );


public static LoadSampleLayout1 : () ==> BaggageTransport
LoadSampleLayout1() ==
  return Load(SampleLayout1);

public static Load : TransportLayout ==> BaggageTransport
Load(layout) == 
  (
    dcl bt : BaggageTransport := new BaggageTransport();
    def mk_(stationSeq, distanceMatrix) = layout in
    (
      for station in stationSeq do
      (
        bt.AddStation(station);
      );
      for all i in set inds distanceMatrix do
      (
        for all j in set inds distanceMatrix(i) do
        (
          if distanceMatrix(i)(j) <> 0 
          then (
            dcl s1 : Station := stationSeq(i);
            dcl s2 : Station := stationSeq(j);
            dcl distance : nat1 := distanceMatrix(i)(j);
            dcl segment : Segment := 
              new Segment(s1, s2, distance);
            bt.AddSegment(segment);
            skip;
          );
        );
      );
    );
    return bt;
  );


public GetStation : seq of char ==> Station
GetStation(pStationName) ==
  return stations(pStationName);

public AddStation : Station ==> ()
AddStation(pStation) ==
  (
    stations := stations munion { pStation.GetName() |-> pStation };
  );
-- TODO: Precondition, ensure that station id does not exit

public AddSegment : Segment ==> ()
AddSegment(pSegment) ==
  (
    segments := segments union { pSegment };
  );
-- TODO: Add precondition to ensure that 
-- 1) A segment with the same from and to station cannot exist
-- 2) Two segments with the same set of stations cannot exist

public Step : () ==> ()
Step() ==
  (
    for all station in set rng stations
    do station.Step();

    for all segment in set segments
    do segment.Step();
  );

public ToJSON : () ==> seq of char
ToJSON() ==
  (
    dcl data : seq of char := "";
    dcl tote : [Tote] := nil;
    data := data ^ "{ \"stations\": [";
    data := data ^ ConvertStationsToJSON(rng stations);
    data := data ^ "], \"segments\": [";
    data := data ^ ConvertSegmentsToJSON(segments);
    data := data ^ "]}";
    return data;
  );

private pure ConvertSegmentsToJSON : set of Segment ==> seq of char
ConvertSegmentsToJSON(pSegments) ==
  (
    dcl data : seq of char := "";
    if pSegments <> {}
    then (
      let segment in set pSegments in
      let
        nextJson = ConvertSegmentsToJSON(pSegments \ { segment }),
        source = segment.GetSourceStation(),
        target = segment.GetTargetStation(),
        distance = segment.GetDistance(),
        totePositions = segment.GetTotePositions()
      in (
        data := data ^ "{ \"source\": \"" ^ source.GetName() ^ "\",";
        data := data ^ " \"target\": \"" ^ target.GetName() ^ "\",";
        data := data ^ " \"distance\": " ^ VDMUtil`val2seq_of_char[nat](distance) ^ ",";
        data := data ^ " \"totes\": [";
        data := data ^ ConvertTotePositionsToJSON(totePositions);
        data := data ^ "]}";
        if nextJson <> ""
        then data := data ^ ", " ^ nextJson;
      );
    );
    return data;
  );

private pure ConvertStationsToJSON : set of Station ==> seq of char
ConvertStationsToJSON(pStations) ==
  (
    dcl data : seq of char := "";
    if pStations <> {}
    then (
      let station in set pStations in
      let
        nextJson = ConvertStationsToJSON(pStations \ { station }),
        tote = station.GetCurrentTote()
      in (
        data := data ^ "{ \"name\": \"" ^ station.GetName() ^ "\"";
        data := data ^ ", \"totes\": [";
        if tote <> nil
        then data := data ^ " { \"id\": " ^ VDMUtil`val2seq_of_char[nat](tote.GetId()) ^ " }";
        data := data ^ "]";
        data := data ^ "}";

        if nextJson <> ""
        then data := data ^ ", " ^ nextJson;
      );
    );
    return data;
  );

private pure ConvertTotePositionsToJSON : seq of Segment`TotePosition ==> seq of char
ConvertTotePositionsToJSON(pTotePositions) ==
  (
    dcl data : seq of char := "";
    if pTotePositions <> []
    then (
     let
        totePos = pTotePositions(1),
        nextJson = ConvertTotePositionsToJSON(tl pTotePositions),
        toteId = VDMUtil`val2seq_of_char[nat](totePos.Tote.GetId()),
        position = VDMUtil`val2seq_of_char[nat](totePos.Position)
      in (
        data := "{ \"id\": " ^ toteId ^ ", \"position\": " ^ position ^ "}";
        if nextJson <> ""
        then data := data ^ ", " ^ nextJson;
      );
    );
    return data;
  );

public ToGraphViz : () ==> seq of char
ToGraphViz() ==
  (
    dcl data : seq of char := "";
    data := data ^ "digraph ER {\n";
    for all station in set rng stations
    do data := data ^ GenerateGraphVizNode(station);
    for all segment in set segments
    do data := data ^ GenerateGraphVizEdge(segment);
    data := data ^ "}\n";
    return data;
  );

private pure GenerateGraphVizEdge : Segment ==> seq of char
GenerateGraphVizEdge(segment) ==
  (
    dcl data : seq of char := "";
    dcl label : seq of char := "";
    label := label ^ VDMUtil`val2seq_of_char[nat1](segment.GetDistance()) ^ " ";
    for totePos in segment.GetTotePositions()
    do (
      label := label ^ "t" ^ VDMUtil`val2seq_of_char[nat](totePos.Tote.GetId());
      label := label ^ ":" ^ VDMUtil`val2seq_of_char[nat](totePos.Position);
      label := label ^ " ";
    );
    data := data ^ "  ";
    data := data ^ segment.GetSourceStation().GetName();
    data := data ^ " -> ";
    data := data ^ segment.GetTargetStation().GetName();
    data := data ^ " [ ";
    data := data ^ " label=\"" ^  label ^  "\"";
    data := data ^ " ]";
    data := data ^ ";\n";
    return data;
  );

private pure GenerateGraphVizNode : Station ==> seq of char
GenerateGraphVizNode(station) ==
  (
    dcl data : seq of char := "  ";
    data := data ^ station.GetName();
    data := data ^ " [label=\""  ^ station.GetName();
    if station.GetCurrentTote() <> nil then
    (
      data := data ^ "\\nt:" ^ VDMUtil`val2seq_of_char[nat](station.GetCurrentTote().GetId());
    );

    data := data ^ "\"];\n";
    return data;
  );

functions


traces
-- TODO Define Combinatorial Test Traces here
end BaggageTransport