class Segment is subclass of Global

instance variables

private source : Station;
private target : Station;
private distance : Distance;
private totePositions : inmap Tote to nat;

operations

public Segment : Station * Station * Distance  ==> Segment
Segment(pSourceStation, pTargetStation, pDistance) ==
  (
    source := pSourceStation;
    target := pTargetStation;
    distance := pDistance;

    -- Back reference
    source.AddSegment(self);
    target.AddSegment(self);

    totePositions := { |-> };
  )
-- Ensure that source and destination stations are different.
pre pSourceStation.GetId() <> pTargetStation.GetId();

public pure GetSourceStation : () ==> Station
GetSourceStation() == return source;

public pure GetTargetStation : () ==> Station
GetTargetStation() == return target;

-- Determines whether the given station is on this segment.
public pure HasStation : Station ==> bool
HasStation(pStation) ==
  return pStation.GetId() = source.GetId() or
         pStation.GetId() = target.GetId();

public pure IsSource : Station ==> bool
IsSource(pStation) ==
  return pStation.GetId() = source.GetId();

public pure IsTarget : Station ==> bool
IsTarget(pStation) ==
  return pStation.GetId() = target.GetId();

public pure CanProcess : Tote ==> bool
CanProcess(pTote) ==
  return card dom totePositions = 0 or
    let rearTote    = GetRearTote(),
        rearTotePos = totePositions(rearTote)
    in
        rearTotePos - rearTote.GetLength() >= pTote.GetLength();

public Process : Tote ==> ()
Process(pTote) ==
  (
    totePositions := totePositions munion { pTote |-> pTote.GetLength() };
  )
pre
  -- Ensure that the given tote is not already on the segment
  forall tote in set dom totePositions & tote.GetId() <> pTote.GetId()
  -- And we can actually process the tote.
  and CanProcess(pTote);

public Step : () ==> ()
Step() ==
  (
    for all tote in set dom totePositions
    do
      let newPosition = totePositions(tote) + tote.GetLength()
      in
        totePositions := totePositions ++ { tote |-> newPosition };

    -- TODO:
    -- 1) Find the next tote to process
    -- 2) If the target station can process the tote
    -- 3)   Call TargetStation.Process(tote)
    -- 4)   Remove tote from the segment
    -- 5) Change the position of all totes
  );

public pure GetRearTote : () ==> Tote
GetRearTote() ==
  let rearTotePos in set rng totePositions
  be st
    forall pos in set rng totePositions &
    rearTotePos <> pos => rearTotePos < pos
  in
    return (inverse totePositions)(rearTotePos)
pre card dom totePositions > 0;

end Segment